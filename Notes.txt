!!!! GENERAL NOTES !!!!!
In order for Specificaton class to be properly mapped when sending it through the POST (if the desired result is for it to be mapped directly from the recieved
request JSON), it needs to have a default constructor and setters and non final fields!!!!


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
First Section

///////////////////////////////////////
First video /////////////////////////// - EJBs and CDI managed beans
///////////////////////////////////////

What is the stateless annotation? -> https://stackoverflow.com/questions/13487987/where-to-use-ejb-3-1-and-cdi/13504763#13504763
stateless vs stateful -> A Stateful bean will have state associated with it for each request from the same client. Stateless beans have no client specific state and a single instance could be used concurrently, threadsafe, between multiple clients requests.

How to tell if its EJB or CDI?
EJB -> has @Stateless @Stateful or @Singleton annotated on the class
CDI -> has no class annotation

///////////////////////////////////////
second video ////////////////////////// - CDI producers
///////////////////////////////////////

producers? -> a way to inject common values for enums  @Produces annotation -> can be used both in methods or fields

///////////////////////////////////////
third video /////////////////////////// - Qualifiers
///////////////////////////////////////

Qualifier annotations -> make sure the default stuff is being assigned to it -> @Named works but it can be ambigous and not type safe -> create custom qualifer annotation, see @Diesel in the project


///////////////////////////////////////
fourth video ////////////////////////// - Scopes
///////////////////////////////////////

Scopes ->

EJB
@Stateless -> pooled by container, unsure which instance is used when a request arrives. Should never have data or state
@Statefull -> its user request scopped and its maintained throughout the request, can contain data or state
@Singleton -> locked single instance for the whole application

CDI
@ApplicationScopped -> similar to @Singleton
@RequestScopped -> similar to @Statefull
@Dependent -> default scope no annotation needed, these depend on the injection point lifecycle: carfactory example -> the carRepository lifecycle is dependent on the carfactory lifecycle and only 1 is pooled

///////////////////////////////////////
fifth video /////////////////////////// - Events
///////////////////////////////////////

Events -> Domain events, Synchronous

Perfect way to couple logic loosely together, needs an Event<T> in which T is a POJO containing the necessary data and then
an observer class watching for the event fired on that class that implements some logic.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Second section

///////////////////////////////////////
First video /////////////////////////// - JAX-RS resources
///////////////////////////////////////

Http endpoints -> JAX RS
JAXRSConfiguration extends Application -> defines the root path and other application configuration
car resource -> path defines the path after baseUrl/JAXRSConfigurationPath/finalPath
Produces annotation on class means that all the endpoints will produce that, further specification can be done in every endpoint
@GET, @POST , etc... the general use HTTP methods
In case of specification param on the get retrieve cars !!!!!!!!!POJO needs a default constructor + full constructor and the POJO fields cannot be final!!!!!!!!

///////////////////////////////////////
second video ////////////////////////// Integrating Json-B
///////////////////////////////////////

Integrating JSON-B from JSON binding
@JsonbTransient -> field wont be serialized when converting obj to byte
@JsonbProperty -> replaces the key name on the final json conversion to the string present on the annotation


///////////////////////////////////////
third video /////////////////////////// - Integrating JSON-P
///////////////////////////////////////

JSON - P -> creating and using JSON objects with java 8 streams
JsonArray -> type that returns an Array of Json objects as response
JsonObject -> type that represents the json object, can be accessed the same way as it is in JS
Json.createObjectBuilder() -> initializes a json object and returns it so it is possible to chain add and other nested objects too


!!!!Removed specification default constructor (and final keyword form fields) since it is now immutable since it is only created and used in a single method!!!

///////////////////////////////////////
fourth video ////////////////////////// - Custom HTTP responses
///////////////////////////////////////

URI and using response -> USE URIInfo to dynamically build the URI through the context.
both of these objects use the builder pattern

///////////////////////////////////////
fifth video /////////////////////////// - Validating communication
///////////////////////////////////////

JaxRS validations -> @NotNull , @Size , @Min, @Max, @Email... etc
@Valid -> runes the validations for the class
@QueryParam("filter") --> this reads the parameter sent in the URL (URL/?filter=...)
CUSTOM VALIDATOR -> see EnvironmentalFiendly annotation -> EnvironmentalFriendlyValidator -> annontation in filed, param, etc
!!!This validator was made for specification, it is only meant for the createCar endpoint!!!!
Another validation option is to use the Validator from javax.validation.Validator;


///////////////////////////////////////
sixth video /////////////////////////// - Exception handling
///////////////////////////////////////

JaxRS can intercept exceptions and build a custom response for it, it needs the specific exception created
the handler created -> see CarCreationExceptionHandler with the @Provider annotation
See also ConstrainViolationExceptionHandler -> it builds a custom response to any bean validation exception

However, if CarCreationException extends runtimeException it will be logged, this is not the desired effect.
A solution is to implement the throws in the method (polutes the programming model). Another solution is to add @ApplicationException
So with the annotation the exception will no longer be wrapped as an EJB exception but as a ApplicationException

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Third section

///////////////////////////////////////
First video /////////////////////////// - Mapping Domain entities with JPA
///////////////////////////////////////

Annotate domain model with @Entity to map it, @Table to define the table name --> see Car model
persistance.xml MUST BE inside the folder src/main/resouces/META-INF
must define the Persistence unit
Entity manager can be instanced in the controller with @PersistenceContext with optional string to point to a specific one

@NamedQuerries(
{@NamedQuery(name ="..." query = "JQL query statement")}
) -> This can be done to make easy to use general queries. to add JQL parameters do ?1 , ?2 and etc, when creating the query,
add .setParameter(1, "someString") to set the parameter for example.
OR
use :parameterName and then .setparameter("parameterName", "some str or object")

entityManager.find(ModelClass.class, "ID string or number") -> to find a specific entity in the db.

///////////////////////////////////////
second video ////////////////////////// - Entity Relations
///////////////////////////////////////

for enum types that need to be persisted -> @Enumerated(EnumType.STRING) from string enums.

Seat model has a SeatMaterial which is an enum
Seat model has a Seatbelt is domain driven design value object which means it is not an entity so we dont care if its identifiable
SeatBelt has a SeatBeltModel which is an enum

To relate an entity with another one use @OneToMany, OneToOne, etc.
cascade ->  CascadeType.All when creating a new one it will recursively create all the other entities
fetch -> fetchType.Eager will do eager fetching

@JoinColumn(name = "seats", nullable = false) --> this will be the name of the column with the external key

domain driven design value object -> should be annotated with @Embedded when they are fields in other entities and
the class should have @Embeddable

This means that the SeatBelt is a Embeddable it will take every field it has (SeatBeltModel enum) and put them in a collumn
on the seats table.

///////////////////////////////////////
third video /////////////////////////// - Datasources
///////////////////////////////////////